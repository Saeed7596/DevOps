# Practical Example: Granting Access to a User in Kubernetes
Let's create a user in Kubernetes, grant them access, and configure the necessary files so they can connect to the cluster. We'll use `Role`, `RoleBinding`, `Secret`, and the `kubeconfig` file. Finally, I'll explain how authentication works and how the user logs into the cluster.

---

## Scenario:
Assume you have a user named "Ali" who should only be able to view Pods in a specific Namespace (e.g., `team-a`) (read-only, no deletion or modification). Now, you want to set up this access from start to finish.

---

## Step 1: Create a ServiceAccount for the User
In Kubernetes, users or `ServiceAccounts` are used as "identities" to access the cluster. So, the first step is to create a ServiceAccount for our user.
```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: ali-sa
  namespace: team-a
```
### What does it do?
This file creates a ServiceAccount named `ali-sa` in the `team-a` Namespace. This ServiceAccount defines the identity of the user "Ali" in the cluster.

---

## Step 2: Create a Role to Limit Access
Now, we need to define the necessary permissions. The user should only be able to read Pods in the `team-a` Namespace, so we create a Role.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: team-a
  name: pod-reader
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]
```
### What does it do?
This Role allows anyone bound to it to:
* Read Pod information (`get`).
* List Pods (`list`).
* Watch Pod changes (`watch`).
* All of this is limited to the `team-a` Namespace.

---

## Step 3: Bind the Role to the ServiceAccount with RoleBinding
Now, we need to bind the Role to the `ali-sa` ServiceAccount so that the permissions defined in the Role are granted to this ServiceAccount.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: pod-reader-binding
  namespace: team-a
subjects:
- kind: ServiceAccount
  name: ali-sa
  namespace: team-a
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```
### What does it do?
This file says, "Bind the `pod-reader` Role we defined to the `ali-sa` ServiceAccount in the `team-a` Namespace."

---

## Step 4: Get a Token from the ServiceAccount
Now that the ServiceAccount is created and bound to a Role, we need to get a Token from this ServiceAccount so the user can authenticate.

Command to get the Secret related to the ServiceAccount:
```bash
kubectl get secret -n team-a
```
Output:
```
NAME                        TYPE                                  DATA   AGE
ali-sa-token-abc123         kubernetes.io/service-account-token   3      1m
```
View the Token content:
```bash
kubectl describe secret ali-sa-token-abc123 -n team-a
```
In the output, you'll see the JWT token. It looks something like this:
```
eyJhbGciOiJSUzI1NiIsImtpZCI6Im... (a long string)
```
This Token is what the user "Ali" needs for authentication.

---

## Step 5: Create a kubeconfig File for the User
Now, we need to create a kubeconfig file for the user so they can connect to the cluster. This file stores cluster information, user details, and the Token.
```yaml
apiVersion: v1
kind: Config
clusters:
- cluster:
    certificate-authority-data: <CA_DATA> # Cluster certificate (Base64)
    server: https://<KUBERNETES_API_SERVER> # API server address
  name: my-cluster
contexts:
- context:
    cluster: my-cluster
    namespace: team-a # Restrict to a specific Namespace
    user: ali-user
  name: ali-context
current-context: ali-context
users:
- name: ali-user
  user:
    token: <ALI_TOKEN> # Ali's ServiceAccount Token
```
### Explanation:
* `certificate-authority-data`: This is the cluster certificate, which you can get using the command:
 - `kubectl config view --raw`
* `server`: The API server address of the cluster.
* `token`: The JWT token we got from the Secret.

---

## How Does Authentication Work in Kubernetes?
When the user "Ali" connects to the cluster using the kubeconfig file:

1. Authentication:
- Kubernetes checks the JWT token to ensure it is valid (issued by the ali-sa ServiceAccount).

2. Authorization:
- Kubernetes checks whether this ServiceAccount has permission to perform the requested action (e.g., reading Pods). This is done by checking the Role and RoleBinding.

---

## Step 6: How User Ali Uses the Access
1. Save the above file as `config`.
3. Tell user Ali to copy this file to the `~/.kube/config` path:
```bash
mkdir -p ~/.kube
cp config ~/.kube/config
```
3. Now, user Ali can run `kubectl` commands. For example:
```bash
kubectl get pods -n team-a
```
User Ali can now view the list of Pods in the `team-a` Namespace.

---

## Summary:
1. Create a ServiceAccount:
- To define the user's identity.

2. Define a Role:
- To specify permissions.

3. Create a RoleBinding:
- To bind the Role to the ServiceAccount.

4. Get a Token:
- For user authentication.

5. Create a kubeconfig:
- So the user can connect to the cluster.


---

# How to Create a New User in Kubernetes
In Kubernetes, users are not managed directly by the system. Instead, Kubernetes uses kubeconfig files and authentication mechanisms (like certificates, tokens, etc.) to manage users. Below are the steps to create a new user in Kubernetes.
---
1. Generate a Certificate for the New User
To create a new user, you need to generate an SSL certificate for authentication.

    Steps to Generate a Certificate:
    1. Generate a Private Key:
    ```bash
    openssl genpkey -algorithm RSA -out user.key
    ```
    2. Create a Certificate Signing Request (CSR):
    ```bash
    openssl req -new -key user.key -out user.csr -subj "/CN=<username>/O=<group>"
    ```
    - Replace `<username>` with the desired username.

    - Replace `<group>` with the group the user belongs to (optional).

    3. Sign the Certificate Using the Kubernetes CA:
    ```bash
    openssl x509 -req -in user.csr -CA /path/to/ca.crt -CAkey /path/to/ca.key -CAcreateserial -out user.crt -days 365
    ```
    - Replace `/path/to/ca.crt` and `/path/to/ca.key` with the paths to your Kubernetes CA files.

2. Add the User to the `kubeconfig` File
After generating the certificate, add the new user to the `kubeconfig` file.

    1. Add the User to kubeconfig:
    ```bash
    kubectl config set-credentials <username> --client-certificate=user.crt --client-key=user.key
    ```
    2. Create a New Context for the User:
    ```bash
    kubectl config set-context <context-name> --cluster=<cluster-name> --namespace=<namespace> --user=<username>
    ```
    - Replace `<context-name>` with a name for the new context.
    - Replace `<cluster-name>` with the name of the cluster the user will access.
    - Replace `<namespace>` with the default namespace for the user (optional).
    3.Switch to the New Context:
    ```bash
    kubectl config use-context <context-name>
    ```

3. Set Up Permissions (RBAC) for the New User
After creating the user, you need to assign the necessary permissions using **Role-Based Access Control (RBAC)**.

    1. Create a Role or ClusterRole:
    ```yaml
    apiVersion: rbac.authorization.k8s.io/v1
    kind: Role
    metadata:
      namespace: <namespace>
      name: <role-name>
    rules:
      - apiGroups: [""]
        resources: ["pods"]
        verbs: ["get", "list", "create"]
    ```
    - Replace `<namespace>` with the namespace where the role applies.
    - Replace `<role-name>` with a name for the role.

    2. Create a RoleBinding or ClusterRoleBinding:
    ```yaml
    apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding
    metadata:
      name: <rolebinding-name>
      namespace: <namespace>
    subjects:
      - kind: User
        name: <username>
        apiGroup: rbac.authorization.k8s.io
    roleRef:
      kind: Role
      name: <role-name>
      apiGroup: rbac.authorization.k8s.io
    ```
    - Replace `<rolebinding-name>` with a name for the RoleBinding.
    - Replace `<username>` with the username you created.
    - Replace `<role-name>` with the name of the role you created.

    3. Apply the RBAC Configuration:
    ```bash
    kubectl apply -f role.yaml
    kubectl apply -f rolebinding.yaml
    ```

4. Test the New User's Access
To verify that the new user is set up correctly, use the `kubectl auth can-i` command:
```bash
kubectl auth can-i create pods --as <username>
```
### Important Notes:
- Kubernetes does not manage users in an internal database by default. Users are defined through certificates, tokens, or other authentication methods.
- If you are using an external service like LDAP or OIDC for authentication, the process will differ.
- For internal users (e.g., Service Accounts), use `ServiceAccount` instead.

By following these steps, you can create a new user in Kubernetes and assign the necessary permissions.
