# StatefulSets
## Why Use StatefulSets?

**StatefulSets** in Kubernetes are used for applications that require persistent state and stable, unique network identifiers. They are designed for workloads that need to maintain state across pod restarts, like databases or services that need specific network identities.

### What is a StatefulSet?

A **StatefulSet** is a controller in Kubernetes used to manage stateful applications. Unlike **Deployments** (used for stateless apps), StatefulSets ensure that pods maintain their identity, persistent storage, and stable network names.

### Key Features:
- **Stable, Unique Network Identifiers**: Pods are assigned fixed names (`pod-0`, `pod-1`, ...) that remain consistent across restarts.
- **Persistent Storage**: Each pod gets its own persistent volume (PV) that retains data across pod restarts.
- **Ordered Deployment and Scaling**: Pods are created and terminated in a specific order (e.g., `pod-0` first, then `pod-1`).
- **DNS Names**: Each pod gets a unique DNS name that allows it to be easily discovered in the network.

### Use Cases:
- **Databases**: StatefulSets are ideal for distributed databases like **Cassandra** or **MongoDB** where each pod holds state.
- **Applications** that need stable network identities and persistent storage.

### Example:
For a database like MongoDB, each pod in the StatefulSet might hold part of the database's data and have a stable hostname, such as `mongodb-0`, `mongodb-1`, etc. These names ensure that nodes can communicate reliably and retain their data.

---

Here’s an example of a StatefulSet YAML file for a MongoDB deployment:
```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mongo
spec:
  serviceName: "mongo"  # Use the headless service for stable networking
  replicas: 3
  selector:
    matchLabels:
      app: mongo
  template:
    metadata:
      labels:
        app: mongo
    spec:
      containers:
      - name: mongo
        image: mongo:latest
        ports:
        - containerPort: 27017
        volumeMounts:
        - name: mongo-data
          mountPath: /data/db
  volumeClaimTemplates:
  - metadata:
      name: mongo-data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 1Gi
```
Explanation:
- `replicas`: 3: Creates 3 MongoDB pods.
- `volumeClaimTemplates`: Defines persistent storage for each pod. Each pod will get its own persistent volume (PVC).
- `statefulSet Name`: The StatefulSet is named `mongo`, and each pod will get a name like `mongo-0`, `mongo-1`, `mongo-2`.
- `Service`: The `serviceName: "mongo"` allows the StatefulSet to use a headless service to manage networking and DNS for stable pod communication.
Each MongoDB pod gets its own unique volume and network identity, which is ideal for stateful applications like databases.

## Headless Service in Kubernetes

A **Headless Service** in Kubernetes is a service without a cluster IP. Instead of routing traffic to a single IP, it allows direct access to individual pods via DNS. This is particularly useful for stateful applications like **StatefulSets**.

### Key Features:
- **No ClusterIP**: Set `clusterIP: None` to create a headless service with no shared IP.
- **DNS for Individual Pods**: Each pod gets a unique DNS record (e.g., `pod-0.service-name`, `pod-1.service-name`).
- **Direct Pod Access**: Allows applications to connect directly to individual pods, useful for distributed databases or services.

### Use Cases:
- **StatefulSets**: Ensures stable networking for applications like **MongoDB** or **Cassandra**.
- **Direct Pod Communication**: Enables direct communication between pods for applications that require specific network identities.

### Example:
```yaml
apiVersion: v1
kind: Service
metadata:
  name: mongo
  labels:
    app: mongo
spec:
  clusterIP: None  # Headless service
  selector:
    app: mongo
  ports:
    - port: 27017
      targetPort: 27017
```

---

# Pod Management Policy in StatefulSet

## 1. OrderedReady (Default)
This is the default mode for StatefulSet. When this setting is active, Kubernetes manages Pods in a specific order. Specifically:

- **Creating Pods**: First, `pod-0` is created, and until this Pod reaches the `Ready` state, `pod-1` is not created. After `pod-1` is ready, `pod-2` is created, and so on.
- **Deleting Pods**: Opposite to creation, when you delete a StatefulSet or reduce the number of replicas, Kubernetes starts from the last Pod. For example, `pod-2` is deleted first, then `pod-1`, and finally `pod-0`.
- **Updating Pods**: During updates (e.g., changing the container image), Kubernetes also follows the order. For example, `pod-0` is updated first, then `pod-1`, and so on.

### When to Use OrderedReady?
This mode is ideal for applications that require a specific order for startup or shutdown. Examples include:
- Databases with replica sets (e.g., MongoDB or Cassandra).
- Applications where Pods need to communicate with each other in a specific order.

### What’s the Problem with OrderedReady?
- **Slowness**: Since Pods are created or updated one by one, it may take a long time for all Pods to become ready. For example, if you have 10 Pods, you must wait for each one to become ready sequentially.

---

## 2. Parallel
In this mode, Kubernetes manages Pods in parallel. Specifically:

- **Creating Pods**: All Pods are created simultaneously. For example, `pod-0`, `pod-1`, and `pod-2` start being created at the same time.
- **Deleting Pods**: All Pods can be deleted in parallel.
- **Updating Pods**: Pod updates can also be done in parallel (though this depends on other settings like `partition`).

### When to Use Parallel?
This mode is great for applications that do not require a specific order and need Pods to be created quickly. Examples include:
- Stateless applications that just need to start up quickly.
- When you have a large number of Pods and don’t want to wait for them to be created one by one.

### What’s the Problem with Parallel?
- **Lack of Order**: Since Pods are created simultaneously, applications that require a specific order may face issues.

---

## Comparison: OrderedReady vs. Parallel

### OrderedReady:
1. Kubernetes creates `pod-0` first.
2. When `pod-0` reaches the `Ready` state, `pod-1` is created.
3. When `pod-1` is ready, `pod-2` is created.

### Parallel:
1. Kubernetes creates all Pods (`pod-0`, `pod-1`, `pod-2`) simultaneously.
2. Each Pod becomes `Ready` as soon as it is prepared.

---

## Important Note About Changing Pod Management Policy
You **cannot** change this setting for an existing StatefulSet. If you created a StatefulSet with a specific `podManagementPolicy`, you cannot modify it later. To change it, you must delete the StatefulSet and recreate it with the new settings.

---

## Summary
- **OrderedReady**: Ideal for applications that require a specific order (e.g., databases), but slower.
- **Parallel**: Better for applications where order is not important, and speed is a priority.

The choice between these two depends on your application’s needs and your priorities.
A headless service provides unique DNS names for each pod, ensuring stable and direct communication, ideal for stateful applications.
