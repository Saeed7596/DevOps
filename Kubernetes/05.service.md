# Service
#### Provides stable networking and communication between Pods.
```bash
kubectl get svc
kubectl get service
kubectl describe service
```
### Types of **Service** in Kubernetes

| Service Type    | Description | Common Usage |
|----------------|--------------------------------------------------|------------------------------|
| **ClusterIP**  | The default type, assigns an internal IP within the cluster, accessible only inside the cluster. | Internal communication between services within the cluster |
| **NodePort**   | Opens a port on each Node, allowing access from outside the cluster. | External access without a Load Balancer |
| **LoadBalancer** | Creates a public IP and a Load Balancer from the cloud provider. | Load distribution and direct external access |
| **ExternalName** | Maps requests to an external domain name (e.g., `example.com`). | Redirecting requests to external services |

---

### Differences between **nodePort, port, and targetPort** in Kubernetes

| Parameter      | Description |
|---------------|--------------------------------------------------|
| **nodePort**  | The port opened on each Node, allowing external access (ranges between 30000-32767). |
| **port**      | The port defined in the Service that receives traffic. |
| **targetPort** | The port running inside the Pod that processes incoming requests. |

Example YAML configuration:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: example-service
spec:
  type: NodePort
  ports:
    - port: 80
      targetPort: 8080
      nodePort: 30080
```

In this example:
- Requests arrive at **port 80** on the Service.
- They are forwarded to **port 8080** inside the corresponding Pod.
- The Service is externally accessible on **port 30080** on each Node.

---

```bash
nano service-definition.yaml
kubectl apply -f service-definition.yaml
```
```yaml
apiVersion: v1
kind: Service
metadata:
  name: webapp-service
  namespace: default
spec:
  ports:
  - nodePort: 30080
    port: 8080
    targetPort: 8080
  selector:
    name: simple-webapp
  type: NodePort
```
```bash
kubectl run nginx --image=nginx --port=80 --expose # create a service for this pod

kubectl expose pod redis --port=6379 --name redis-service --dry-run=client -o yaml
kubectl create service clusterip redis --tcp=6379:6379 --dry-run=client -o yaml 
kubectl expose pod nginx --type=NodePort --port=80 --name=nginx-service --dry-run=client -o yaml
kubectl create service nodeport nginx --tcp=80:80 --node-port=30080 --dry-run=client -o yaml

kubectl run redis -l tier=db --image=redis:alpine # -l means Label
kubectl expose pod redis --port=6379 --target-port=6379 --name=redis-service --type=ClusterIP
```

```
# if messaging is deployment
kubectl expose deployment messaging --name=messaging-service --port=6379 --target-port=6379 --type=ClusterIP
# if messaging is pod
kubectl expose pod messaging --name=messaging-service --port=6379 --target-port=6379 --type=ClusterIP
```

---

### Communication Between Pods in Different Namespaces
- By default, Pods in different namespaces cannot directly discover each other. To establish communication, you must use the **full DNS name** of the service.

---

### Exposing Applications

There are several ways to expose applications in Kubernetes:

1. **NodePort**:
   - Exposes the service on a static port on each nodeâ€™s IP.
   - Accessible from outside the cluster using `<NodeIP>:<NodePort>`.

2. **LoadBalancer**:
   - Provisions an external load balancer (e.g., in cloud environments) to expose the service.
   - Automatically assigns an external IP.

3. **Ingress**:
   - Provides HTTP/HTTPS routing to services based on hostnames or paths.
   - Requires an Ingress controller to be installed in the cluster.

---

### How to Check if a Service is Pod-to-Pod
To determine if a service is Pod-to-Pod, you can check the following:

1. **Service Type**:
   - The service type should be `ClusterIP`.
   - Command:  
     ```bash
     kubectl get service <service-name> -n <namespace>
     ```

2. **Service Selector**:
   - The service selector should target internal Pods.

3. **Service Endpoints**:
   - The service endpoints should include the internal IPs of the Pods.
   - Command:  
     ```bash
     kubectl get endpoints <service-name> -n <namespace>
     ```

4. **DNS Testing from Inside a Pod**:
   - Access one of the Pods:  
     ```bash
     kubectl exec -it <pod-name> -n <namespace> -- /bin/bash
     ```
   - Send a request to the service:  
     ```bash
     curl http://<service-name>.<namespace>.svc.cluster.local
     ```
   - If the service is Pod-to-Pod, you should receive a response.

5. **Pod Logs**:
   - Check the logs of the Pods to verify internal communication:  
     ```bash
     kubectl logs <pod-name> -n <namespace>
     ```

---

### Multi-Port Service
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: multi-port-deployment
  labels:
    app: multi-port-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: multi-port-app
  template:
    metadata:
      labels:
        app: multi-port-app
    spec:
      containers:
      - name: multi-port-container
        image: nginx:stable
        ports:
        - containerPort: 80   # HTTP
        - containerPort: 443  # HTTPS
        - containerPort: 8080 # Custom Port
---
apiVersion: v1
kind: Service
metadata:
  name: multi-port-service
spec:
  selector:
    app: multi-port-app
  ports:
  - name: http
    protocol: TCP
    port: 80
    targetPort: 80
  - name: https
    protocol: TCP
    port: 443
    targetPort: 443
  - name: custom-port
    protocol: TCP
    port: 8080
    targetPort: 8080
```


