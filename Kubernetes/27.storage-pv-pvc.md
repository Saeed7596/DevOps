# Types of Storage in Kubernetes
In Kubernetes, storage is divided into several categories, each designed for specific scenarios:

---

## 1. EmptyDir
**What is it?**
A temporary storage space that is created when a Pod is created and deleted when the Pod is removed.
**Where is it used?**
For storing temporary data that is only needed during the lifetime of the Pod.
**Example:**
Storing temporary files that do not need to be retained after the Pod is deleted.
**Advantages:**
- Very simple and fast.
**Disadvantages:**
- Data is lost when the Pod is deleted.
**emptyDir configuration example:**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
  - image: registry.k8s.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /cache
      name: cache-volume
  volumes:
  - name: cache-volume
    emptyDir:
      sizeLimit: 500Mi
```

---

## 2. HostPath
**What is it?**
Storage space on the physical disk of the node where the Pod is running.
**Where is it used?**
For scenarios where data must remain on the same node, such as logs.
**Example:**
Storing application logs on the local disk of the node.
**Advantages:**
- Simple and straightforward.
**Disadvantages:**
- If the Pod is moved to another node, it loses access to the data.
**hostPath configuration example:**
```yaml
---
# This manifest mounts /data/foo on the host as /foo inside the
# single container that runs within the hostpath-example-linux Pod.
#
# The mount into the container is read-only.
apiVersion: v1
kind: Pod
metadata:
  name: hostpath-example-linux
spec:
  os: { name: linux }
  nodeSelector:
    kubernetes.io/os: linux
  containers:
  - name: example-container
    image: registry.k8s.io/test-webserver
    volumeMounts:
    - mountPath: /foo
      name: example-volume
      readOnly: true
  volumes:
  - name: example-volume
    # mount /data/foo, but only if that directory already exists
    hostPath:
      path: /data/foo # directory location on host
      type: Directory # this field is optional
```

---

## 3. Persistent Volume (PV) and Persistent Volume Claim (PVC)
**What is it?**
These are fundamental concepts for managing storage in Kubernetes:
- **PV (Persistent Volume)**: A persistent storage space defined independently.
- **PVC (Persistent Volume Claim)**: A request from an application to use a PV.
**Where is it used?**
For storing important and persistent data.
**Example:**
Storing database data (e.g., MySQL or MongoDB).
**Advantages:**
- Persistent and independent of Pods.
- Can be used with various storage backends (e.g., NFS, AWS EBS, GCP Persistent Disk).
**Disadvantages:**
- Requires more configuration.

---

## 4. ConfigMap and Secret
**What is it?**
For storing indirect data such as:
- **ConfigMap**: For storing application configurations.
- **Secret**: For storing sensitive data like passwords and API keys.
**Where is it used?**
For storing configurations and sensitive data.
**Example:**
Storing database passwords or server addresses.
**Advantages:**
- Secure and practical.
**Disadvantages:**
- Not suitable for large data.
**ConfigMap configuration example:**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: configmap-pod
spec:
  containers:
    - name: test
      image: busybox:1.28
      command: ['sh', '-c', 'echo "The app is running!" && tail -f /dev/null']
      volumeMounts:
        - name: config-vol
          mountPath: /etc/config
  volumes:
    - name: config-vol
      configMap:
        name: log-config
        items:
          - key: log_level
            path: log_level.conf
```

---

## 5. Cloud Volumes
**What is it?**
Storage that uses cloud services:
- AWS EBS (Elastic Block Store)
- Azure Disk
- Google Cloud Persistent Disk
**Where is it used?**
For clusters running on the cloud.
**Example:**
Storing important database data on AWS EBS.
**Advantages:**
- Scalable and reliable.
**Disadvantages:**
- Only works on the cloud.

---

## 6. Network File System (NFS)
**What is it?**
A network-based storage space that can be accessed from multiple nodes.
**Where is it used?**
When multiple Pods need access to shared data.
**Example:**
Storing user-uploaded files.
**Advantages:**
- Shareable across nodes.
**Disadvantages:**
- May have slower performance.
**NFS configuration example:**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
  - image: registry.k8s.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /my-nfs-data
      name: test-volume
  volumes:
  - name: test-volume
    nfs:
      server: my-nfs-server.example.com
      path: /my-nfs-volume
      readOnly: true
```

---

## Components of Storage in Kubernetes

### Persistent Volume (PV):
- A storage resource defined by the admin.
- Like an independent storage space ready for use.

### Persistent Volume Claim (PVC):
- Applications use PVCs to request storage space.
- For example, an application might say: “I need 5 GB of storage.”

### Storage Class:
- A template for defining types of PVs.
- For example, you can say:
  - “Any PV using this Storage Class must be on SSD.”

---

## Summary:
- Kubernetes offers various storage options for different use cases:
  - **EmptyDir**: Temporary storage.
  - **HostPath**: Local node storage.
  - **PV/PVC**: Persistent storage.
  - **ConfigMap/Secret**: For configurations and sensitive data.
  - **Cloud Volumes**: Cloud-based storage.
  - **NFS**: Network-based shared storage.

---

# Storage Engine

The Storage Engine determines how data is stored and managed. Depending on your needs, you can use different types of Storage Engines:

- **File Storage**: For regular files.
- **Block Storage**: For databases and large volumes of data.
- **Object Storage**: For large and unstructured data.
- **Relational and NoSQL**: For structured or unstructured data.
- **In-Memory**: For high-speed access.
- **Distributed**: For scalability and large systems.

## Comparison of Storage Engine Types

| Storage Engine Type | Application | Disadvantages | Advantages |
|---|---|---|---|
| File Storage | Storing regular files like photos and documents | Difficult to manage at large scale | Simple and understandable |
| Block Storage | Databases and large volumes of data | Complex management | High speed |
| Object Storage | Storing large data like videos and backups | Slower speed compared to Block Storage | High scalability |
| Relational Storage | Relational databases like MySQL | Not suitable for large data | Suitable for structured data |
| NoSQL Storage | Unstructured data like logs | Limited support for complex queries | High scalability |
| In-Memory Storage | Cache and real-time systems | High cost, temporary data | Extremely high speed |
| Distributed Storage | Cloud systems and large data | Complex management | Scalability and fault tolerance |

---

# Persistent Volume (PV) & Persistent Volume Claim (PVC)
- `PV`: Persistent volume configured by the administrator.
  It is independent of the Pod and is connected to the PVC.
- `PVC`: A request from a Pod to use a PV.
- A Pod cannot directly connect to a PV; it must use a PVC.
### Access Modes:             
- RWO - ReadWriteOnce
- ROX - ReadOnlyMany
- RWX - ReadWriteMany
- RWOP - ReadWriteOncePod
### Types of **Reclaim Policy**
- Retain -- manual reclamation
- Recycle -- basic scrub (rm -rf /thevolume/*)
- Delete -- delete the volume

| **Reclaim Policy** | **Description** | **Use Case** |
|----------------|--------------------------------------------------|------------------------------|
| **Retain**    | Keeps the PV and its data after PVC deletion, but the PV enters a **Released** state and requires manual cleanup. | When you want to preserve data and reuse the PV with a new PVC. |
| **Delete**    | Deletes the PV and its data when the PVC is deleted (if dynamically provisioned). | Suitable for cloud storage (AWS EBS, GCP PD) where storage should be freed. |
| **Recycle** *(Deprecated)* | Wipes the data (like `rm -rf /data/*`) and makes the PV available again. **(Removed in newer Kubernetes versions.)** | Used in older Kubernetes versions for PV resetting. |

#### Matching Based on Specifications (Binding)

Kubernetes automatically binds a PVC to a matching PV if the following specifications **match**:
- StorageClass (if used)
- Capacity (
  - The PV capacity can be greater than the requested PVC size, but it must not be smaller.
- Access Modes 
Binding PV to PVC
- When a PVC matches a PV, that PV gets bound to the PVC, and its status changes to Bound.

---

```bash
nano pod-vol.yaml
# This pod don't use pvc
```
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: webapp
spec:
  containers:
  - name: event-simulator
    image: kodekloud/event-simulator
    env:
    - name: LOG_HANDLERS
      value: file
    volumeMounts:
    # directory location on container
    - mountPath: /log
      name: log-volume

  volumes:
  - name: log-volume
    hostPath:
      # directory location on host
      path: /var/log/webapp
      # this field is optional
      type: Directory
```

---

```bash
nano pv-definition.yaml
```
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-log
spec:
  persistentVolumeReclaimPolicy: Retain
  accessModes:
    - ReadWriteMany
  capacity:
    storage: 100Mi
  hostPath:
    path: /pv/log
```
```bash
kubectl create -f pv-definition.yaml
```
```bash
nano pvc-definition.yaml
```
```yaml
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: claim-log-1
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 50Mi
```
```bash
kubectl create -f pvc-definition.yaml
```
```bash
nano pod-pv.yaml
# This pod use pvc
```
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: webapp
spec:
  containers:
  - name: event-simulator
    image: kodekloud/event-simulator
    env:
    - name: LOG_HANDLERS
      value: file
    volumeMounts:
    - mountPath: /log
      name: log-volume

  volumes:
  - name: log-volume
    persistentVolumeClaim:
      claimName: claim-log-1
```
---
```bash
kubectl get pv
kubectl get pvc
kubectl delete pvc <pvc-name>
kubectl delete pvc claim-log-1
```
